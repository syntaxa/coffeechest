const { logInfo, logError } = require('./utils/logger');
const { generateHaikuWithRetry } = require('./utils/gemini');
const { GEMINI_PROMPT } = require('./config');
const TelegramBot = require('node-telegram-bot-api');
const cron = require('node-cron');
const moment = require('moment-timezone');
const botConfig = require('./config');
const User = require('./models/User');
const { connectDB } = require('./utils/database');
const { safeSendMessage, initMessenger, broadcastToUsers, isAdmin } = require('./utils/messenger'); // Import broadcastToUsers and isAdmin
//const quickTips = 'Use /settimezone to choose your timezone and /settime HH:MM to set notification time. For now you have to type the full command for time. For example "/settime 08:30". I know this sucks :).  \n\nSend /unregister if you don\'t want to receive messages anymore.';
const quickTips = '–ò—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É /settimezone –¥–ª—è –≤—ã–±–æ—Ä–∞ —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è. –ö–æ–º–∞–Ω–¥–∞ /settime –ø–æ–º–æ–∂–µ—Ç –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –≤—Ä–µ–º—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.\n\n–ö–æ–º–∞–Ω–¥–∞ /unregister –æ—Ç–∫–ª—é—á–∏—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∏ –±–æ—Ç –ø—Ä–æ —Ç–µ–±—è –∑–∞–±—É–¥–µ—Ç.';


const bot = new TelegramBot(botConfig.TELEGRAM_BOT_TOKEN, { polling: true });

// Initialize the messenger with the bot instance
initMessenger(bot);


// Helper function to check if user is registered
async function ensureRegistered(msg) {
  const chatId = msg.chat.id;
  try {
    const user = await User.findOne({ telegramId: chatId.toString() });
    if (!user) {
      safeSendMessage(chatId, '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É–π /start, —á—Ç–æ–±—ã –∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞.');
      return null;
    }
    return user;
  } catch (error) {
    logError(`Error fetching user ${chatId}:`, error);
    safeSendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.');
    return null;
  }
}

// Registration command
// Handle inline keyboard callbacks
bot.on('callback_query', async (query) => {
  const chatId = query.message.chat.id;
  const user = await ensureRegistered(query.message);
  if (!user) {
    return;
  }

  const data = query.data;

  if (data.startsWith('tz ')) {
    const tz = data.split(' ')[1];
    if (!moment.tz.zone(tz)) {
      bot.answerCallbackQuery(query.id, { text: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å!' });
      return;
    }

    try {
      await User.findOneAndUpdate(
        { telegramId: chatId.toString() },
        { timeZone: tz, pendingTimezone: false }
      );
      safeSendMessage(chatId, `–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å ${tz}.`);
      bot.editMessageReplyMarkup({ inline_keyboard: [] }, {
        chat_id: chatId,
        message_id: query.message.message_id
      });
    } catch (error) {
      logError('Timezone update error:', error);
      safeSendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞.');
    }
  } else if (data === 'tz_manual') {
    safeSendMessage(chatId, '–û—Ç–ø—Ä–∞–≤—å —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ Region/City (–Ω–∞–ø—Ä–∏–º–µ—Ä, America/New_York, https://timeapi.io/documentation/iana-timezones):');
    bot.editMessageReplyMarkup({ inline_keyboard: [] }, {
      chat_id: chatId,
      message_id: query.message.message_id
    });
  } else if (data.startsWith('time_hour_')) {
    try {
      const hour = parseInt(data.split('_')[2]);
      await handleHourSelection(chatId, hour);
      bot.editMessageReplyMarkup({ inline_keyboard: [] }, {
        chat_id: chatId,
        message_id: query.message.message_id
      });
    } catch (error) {
      logError('Hour selection error:', error);
      safeSendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ —á–∞—Å–∞.');
    }
  } else if (data.startsWith('time_minute_')) {
    try {
      const minute = data.split('_')[2];
      await handleMinuteSelection(chatId, minute);
      bot.editMessageReplyMarkup({ inline_keyboard: [] }, {
        chat_id: chatId,
        message_id: query.message.message_id
      });
    } catch (error) {
      logError('Minute selection error:', error);
      safeSendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ –º–∏–Ω—É—Ç.');
    }
  } else if (data === 'toggle_haiku') {
    try {
      await handleHaikuToggle(chatId, user);
      bot.editMessageReplyMarkup({ inline_keyboard: [] }, {
        chat_id: chatId,
        message_id: query.message.message_id
      });
    } catch (error) {
      logError('Haiku toggle error:', error);
      safeSendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ —Ö–∞–π–∫—É.');
    }
  } else if (data === 'toggle_dessert') {
    const newState = !user.dessertSettings?.enabled;
    await updateDessertSettings(chatId, {
      ...user.dessertSettings,
      enabled: newState
    });
  } else if (data.startsWith('prob_')) {
    const probability = parseInt(data.split('_')[1]);
    await updateDessertSettings(chatId, {
      ...user.dessertSettings,
      probability
    });
  } else if (data === 'close_dessert') {
    try {
      bot.editMessageReplyMarkup({ inline_keyboard: [] }, {
        chat_id: chatId,
        message_id: query.message.message_id
      });
    } catch (error) {
      logError('Close dessert keyboard error:', error);
      safeSendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –º–µ–Ω—é.');
    }
  }
});


async function handleStart(msg, chatId) {
  try {
    let existingUser = await User.findOne({ telegramId: chatId.toString() });
    logInfo(`Processing /start for user: ${msg.from.username} (${chatId.toString()})`);

    if (existingUser) {
      safeSendMessage(chatId, '–¢—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω! üëç');
      return;
    }

    existingUser = new User({
      telegramId: chatId.toString(),
      username: msg.from.username
    });
    await existingUser.save();

    safeSendMessage(chatId, '–ü—Ä–∏–≤–µ—Ç! ' + quickTips);
  } catch (error) {
    logError('Registration error:', error);
    safeSendMessage(chatId, '–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏');
  }
}

async function handleUnregister(chatId, user) {
  try {
    const result = await User.deleteOne({ telegramId: chatId.toString() });
    if (result.deletedCount > 0) {
        safeSendMessage(chatId, '–ë–æ—Ç –∑–∞–±—ã–ª –ø—Ä–æ —Ç–µ–±—è. –ü–æ–∫–∞! üëã');
    } else {
        safeSendMessage(chatId, '–¢—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –≤ –±–æ—Ç–µ. –ò—Å–ø–æ–ª—å–∑—É–π /start, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ—Ç.');
    }
  } catch (error) {
    logError('Unregister error:', error);
    safeSendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.');
  }
}

async function handleSetTimezone(chatId, user) {
  User.findOneAndUpdate(
    { telegramId: chatId.toString() },
    { pendingTimezone: true }
  ).then(() => {
    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: '–õ–æ–Ω–¥–æ–Ω', callback_data: 'tz Europe/London' },
            { text: '–ú–æ—Å–∫–≤–∞', callback_data: 'tz Europe/Moscow' },
            { text: '–î—É–±–∞–π', callback_data: 'tz Asia/Dubai' }
          ],
          [
            { text: '–ù—å—é-–ô–æ—Ä–∫', callback_data: 'tz America/New_York' },
            { text: '–ß–∏–∫–∞–≥–æ', callback_data: 'tz America/Chicago' },
            { text: '–õ–æ—Å –ê–Ω–¥–∂–µ–ª–µ—Å', callback_data: 'tz America/Los_Angeles' }
          ],
          [
            { text: '–†—É—á–Ω–æ–π –≤–≤–æ–¥', callback_data: 'tz_manual' }
          ]
        ]
      }
    };
    safeSendMessage(chatId, '–í—ã–±–µ—Ä–∏ —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å:', keyboard);
  });
}

async function handleTimeSelectionStart(chatId, user) {
  try {
    await User.findOneAndUpdate(
      { telegramId: chatId.toString() },
      { 
        pendingTimeUpdate: true,
        selectedHour: null
      }
    );

    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: '6—á', callback_data: 'time_hour_6' },
            { text: '7—á', callback_data: 'time_hour_7' },
            { text: '8—á', callback_data: 'time_hour_8' },
            { text: '9—á', callback_data: 'time_hour_9' }
          ],
          [
            { text: '10—á', callback_data: 'time_hour_10' },
            { text: '11—á', callback_data: 'time_hour_11' },
            { text: '12—á', callback_data: 'time_hour_12' },
            { text: '13—á', callback_data: 'time_hour_13' }
          ],
          [
            { text: '14—á', callback_data: 'time_hour_14' },
            { text: '15—á', callback_data: 'time_hour_15' },
            { text: '16—á', callback_data: 'time_hour_16' },
            { text: '17—á', callback_data: 'time_hour_17' }
          ]
        ]
      }
    };
    safeSendMessage(chatId, '–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –≤—Ä–µ–º—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —à–∞–Ω—Å–∞ –Ω–∞ –∫–æ—Ñ–µ. –í—Ä–µ–º—è -- —Ç–≤–æ—ë –º–µ—Å—Ç–Ω–æ–µ\n\n–í—ã–±–µ—Ä–∏ —á–∞—Å:', keyboard);
  } catch (error) {
    logError('Error starting time selection:', error);
    safeSendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ –≤—Ä–µ–º–µ–Ω–∏.');
  }
}

async function handleHourSelection(chatId, hour) {
  try {
    await User.findOneAndUpdate(
      { telegramId: chatId.toString() },
      { selectedHour: hour }
    );

    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: '00–º', callback_data: 'time_minute_00' },
            { text: '10–º', callback_data: 'time_minute_10' },
            { text: '20–º', callback_data: 'time_minute_20' }
          ],
          [
            { text: '30–º', callback_data: 'time_minute_30' },
            { text: '40–º', callback_data: 'time_minute_40' },
            { text: '50–º', callback_data: 'time_minute_50' }
          ]
        ]
      }
    };
    safeSendMessage(chatId, '–í—ã–±–µ—Ä–∏ –º–∏–Ω—É—Ç—ã:', keyboard);
  } catch (error) {
    logError('Error handling hour selection:', error);
    safeSendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ —á–∞—Å–∞.');
  }
}

async function handleMinuteSelection(chatId, minute) {
  try {
    const user = await User.findOne({ telegramId: chatId.toString() });
    if (!user || !user.selectedHour) {
      safeSendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫—É –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–Ω–æ–≤–æ —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /settime.');
      return;
    }

    const time = `${user.selectedHour.toString().padStart(2, '0')}:${minute}`;
    await User.findOneAndUpdate(
      { telegramId: chatId.toString() },
      { 
        notificationTime: time,
        pendingTimeUpdate: false,
        selectedHour: null
      }
    );

    safeSendMessage(chatId, `–í—Ä–µ–º—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –Ω–∞ ${time}.`);
  } catch (error) {
    logError('Error handling minute selection:', error);
    safeSendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ –≤—Ä–µ–º–µ–Ω–∏.');
  }
}

async function handleSetTime(chatId, user) {
  await handleTimeSelectionStart(chatId, user);
}

async function handleSendHaiku(chatId, user) {
  const currentState = user.sendHaiku === null ? true : user.sendHaiku;
  const keyboard = {
    reply_markup: {
      inline_keyboard: [
        [{ text: `–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–µ–π—á–∞—Å: ${currentState ? '‚úÖ' : '‚ùå'} –ù–∞–∂–º–∏, —á—Ç–æ–±—ã –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å`, callback_data: 'toggle_haiku' }]
      ]
    }
  };
  safeSendMessage(chatId, '–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤—ã–¥—É–º–∞–Ω–Ω–æ–≥–æ —Å—Ç–∏—à–∫–∞ –≤–º–µ—Å—Ç–µ —Å –∫–æ—Ñ–µ–π–Ω—ã–º –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏–µ–º', keyboard);
}

async function handleHaikuToggle(chatId, user) {
  const newState = user.sendHaiku === null ? false : !user.sendHaiku;
  await User.findOneAndUpdate(
    { telegramId: chatId.toString() },
    { sendHaiku: newState }
  );
  safeSendMessage(chatId, `–ü—Ä–∏—Å—ã–ª–∞—Ç—å —Ö–∞–π–∫—É ${newState ? '‚úÖ' : '‚ùå'}`);
}

async function handleBroadcast(chatId, user, args) {
  if (!isAdmin(chatId.toString())) {
    safeSendMessage(chatId, '–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.');
    return;
  }

  const message = args.join(' ');
  if (!message.trim()) {
    safeSendMessage(chatId, '–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.');
    return;
  }

  try {
    const successfulSends = await broadcastToUsers(message);
    safeSendMessage(chatId, `–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ ${successfulSends} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.`);
  } catch (error) {
    logError('Broadcast error:', error);
    safeSendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è.');
  }
}

async function handleUnknownCommand(chatId, user) {
  safeSendMessage(chatId, '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞.\n\n' + quickTips);
}

async function handleNonCommandMessage(chatId, user) {
  safeSendMessage(chatId, '–Ø –Ω–µ –ø–æ–Ω–∏–º–∞—é.\n\n' + quickTips);
}

async function handleSetCookie(chatId, user) {
  const keyboard = {
    reply_markup: {
      inline_keyboard: [
        [
          { text: `–î–µ—Å–µ—Ä—Ç —Å–µ–π—á–∞—Å: ${user.dessertSettings?.enabled ? '‚úÖ' : '‚ùå'}`, callback_data: 'toggle_dessert' }
        ],
        [
          { text: `${user.dessertSettings?.probability === 20 ? '‚úÖ ' : ''}–®–∞–Ω—Å 20%`, callback_data: 'prob_20' },
          { text: `${user.dessertSettings?.probability === 40 ? '‚úÖ ' : ''}–®–∞–Ω—Å 40%`, callback_data: 'prob_40' },
          { text: `${user.dessertSettings?.probability === 60 ? '‚úÖ ' : ''}–®–∞–Ω—Å 60%`, callback_data: 'prob_60' },
          { text: `${user.dessertSettings?.probability === 80 ? '‚úÖ ' : ''}–®–∞–Ω—Å 80%`, callback_data: 'prob_80' }
        ],
        [
          { text: '–ó–∞–∫—Ä—ã—Ç—å', callback_data: 'close_dessert' }
        ]
      ]
    }
  };
  safeSendMessage(chatId, 'üç™ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –¥–µ—Å–µ—Ä—Ç–∞ –∫ –∫–æ—Ñ–µ', keyboard);
}

async function updateDessertSettings(chatId, update) {
  try {
    await User.findOneAndUpdate(
      { telegramId: chatId.toString() },
      { $set: { dessertSettings: update } }
    );
    const updatedUser = await User.findOne({ telegramId: chatId.toString() });
    if (!updatedUser) {
      throw new Error('User not found after update');
    }
    await handleSetCookie(chatId, updatedUser);
  } catch (error) {
    logError('Dessert settings update error:', error);
    safeSendMessage(chatId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ –¥–µ—Å–µ—Ä—Ç–∞.');
  }
}

// Handle all incoming messages and commands
bot.on('message', async (msg) => {
  const chatId = msg.chat.id;
  const text = msg.text;

  // avoiding system messages like 'user xyz was added' etc
  if(text) {
    // Handle start command
    if (text.toLocaleLowerCase() === '/start') {
      await handleStart(msg, chatId);
      return;
    } // Stop processing if handling start command

    // All other commands require user to be registered with bot
    const user = await ensureRegistered(msg);
    if (!user) return;

    // Handle manual timezone input if pending
    if (user.pendingTimezone) {
      if (moment.tz.zone(text)) {
        await User.findOneAndUpdate(
          { telegramId: chatId.toString() },
          { timeZone: text, pendingTimezone: false }
        );
        safeSendMessage(chatId, `–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å ${text}.`);
      } else {
        safeSendMessage(chatId, '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞ –ø–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π /settimezone –¥–ª—è –≤—ã–±–æ—Ä–∞ —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞ –∏–∑ —Å–ø–∏—Å–∫–∞.');
      }
      return; // Stop processing if handling pending timezone
    }

    // Handle commands
    if (text.startsWith('/')) {
      const [command, ...args] = text.slice(1).split(' ');
      const lowerCaseCommand = command.toLowerCase();

      switch (lowerCaseCommand) {
        case 'unregister':
          await handleUnregister(chatId, user);
          break;
        case 'settimezone':
          await handleSetTimezone(chatId, user);
          break;
        case 'settime':
          await handleSetTime(chatId, user);
          break;
        case 'sendhaiku':
          await handleSendHaiku(chatId, user);
          break;
        case 'setcookie':
          await handleSetCookie(chatId, user);
          break;
        case 'broadcast':
          await handleBroadcast(chatId, user, args);
          break;
        default:
          await handleUnknownCommand(chatId, user);
          break;
      }
    } else {
      await handleNonCommandMessage(chatId, user);
    }
  }
});

// Cron job to check every minute on working days
// todo: improve scalability
function setCronTask() {
  cron.schedule('* * * * 1-5', async () => {
    try {
      const users = await User.find();
      for (const user of users) {
        const now = moment().tz(user.timeZone);
        const [targetHour, targetMinute] = user.notificationTime.split(':');

        if (now.hours() === parseInt(targetHour) && now.minutes() === parseInt(targetMinute)) {
          const hasWon = Math.random() < 0.5;
          logInfo(`User ${user.username} rolled: ${hasWon}`);

          if (hasWon) {
            let messageToSend = botConfig.WIN_MESSAGE;
            
            // Check for dessert win if enabled
            if (user.dessertSettings?.enabled) {
              const dessertProbability = user.dessertSettings.probability / 100;
              const hasWonDessert = Math.random() < dessertProbability;
              if (hasWonDessert) {
                messageToSend += '\n\n–ù—É –∏ –¥–µ–Ω—ë–∫ üåû! –¢–µ–±–µ –≤—ã–ø–∞–ª –µ—â—ë –∏ –¥–µ—Å–µ—Ä—Ç üç∞!';
              }
            }

            const shouldSendHaiku = user.sendHaiku === null ? true : user.sendHaiku;
            if (shouldSendHaiku) {
              let haiku = await generateHaikuWithRetry(
                GEMINI_PROMPT,
                botConfig.GEMINI_MODEL_NAME,
                botConfig.GEMINI_TEMPERATURE,
                botConfig.GEMINI_MAX_OUTPUT_TOKENS
              );
              messageToSend += '\n\n' + haiku;
            }

            try {
              await safeSendMessage(user.telegramId, messageToSend);
            } catch (error) {
              if ((error.response) && (error.response.statusCode === 403)) {
                // User has blocked the bot, delete them from the database
                await User.deleteOne({ telegramId: user.telegramId });
                logInfo(`User ${user.username} (${user.telegramId}) was blocked and unregistered.`);
              } else {
                logError(`Error sending message to ${user.telegramId}:`, error.message);
              }
            }
          }
        }
      }
    } catch (error) {
      logError('Cron error:', error);
    }
  }, {
    timezone: 'Etc/UTC'
  });
}

async function setupBotCommands() {
  try {
    await bot.setMyCommands([
      { command: 'start', description: '–ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞' },
      { command: 'settime', description: '–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –≤—Ä–µ–º—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —à–∞–Ω—Å–∞ –Ω–∞ –∫–æ—Ñ–µ' },
      { command: 'settimezone', description: '–ù–∞—Å—Ç—Ä–æ–∏—Ç—å —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å' },
      { command: 'sendhaiku', description: '–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É —Ö–∞–π–∫—É' },
      { command: 'setcookie', description: '–î–µ—Å–µ—Ä—Ç –∫ –∫–æ—Ñ–µ' },
      { command: 'unregister', description: '–û—Ç–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è' }
    ]);
    logInfo('Bot commands set up successfully');
  } catch (error) {
    logError('Error setting up bot commands:', error);
  }
}

async function main() {
  await connectDB();

  try {
    await require('./utils/migrations')();
  } catch (error) {
    logError('Migration failed:', error);
    process.exit(1);
  }

  await setupBotCommands();
  setCronTask();

  bot.on('error', (error) => {
    logError('Bot error:', error);
  });
}

main();

module.exports = bot;
